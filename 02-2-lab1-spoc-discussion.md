# 02-2-lab1-spoc-discussion

计44 黄锐皓 2014011385

## 思考题

### 启动顺序

1. 段寄存器的字段含义和功能有哪些？

- CS: code segment, 当前程序代码所在段的基址
- SS: stack segment, 当前使用堆栈所在段的基址
- DS: data segment, 当前使用数据所在段的基址
- ES: extra segment, 当前使用附加数据段的段基址

2. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

- DPL：描述符特权级，存放在段描述符中的权限位，用来描述对应段所属的特权级别，也是段本身真正的特权级。

- CPL：当前特权级。保存在CS段寄存器的低两位，是当前活动代码段的特权级，定义了当前所执行程序的特权级别。

- RPL：请求特权级是通过选择子的低两位表现出来的。RPL说明的是进程对段访问的请求权限。RPL值对程序员透明。

  访问时满足 **max(RPL,CPL) <= RPL**。
3. 分析可执行文件格式elf的格式（无需回答）

### 4.2 C函数调用的实现

### 4.4 x86中断处理过程

1. 中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

硬件把eflags、cs、eip、错误码err code依次压栈。 用户态中断涉及特权级的切换，即堆栈的切换，需要额外将ss和esp寄存器压栈，而内核态中断不需要。

2. 为什么在用户态的中断响应要使用内核堆栈？

因为对应的中断处理例程在内核中，需要ring0特权级。在用户态的中断响应必须发生特权级的转换，并调入内核代码执行。

3. trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

trap是陷阱，interrupt是中断。后者的优先级更高。如果不做区分，可能出现中断无法打断陷阱的情况。

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析

1. 在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

因为read_ebp是内核态，需要不被调用直接使用，而read_eip是用户态。

### 4.9 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

不是使能的，因为未设置中断表。